## future（面试扫读版：可扩展方向）

> 这份是“你未来怎么演进”的口径：什么时候做、怎么做、风险点是什么、怎么治理。

---

## 0) Docker 生产发布：怎么把镜像发布到服务器？

### 一句话答案

本质就是 **CI 构建镜像 → 推送镜像仓库 → 服务器拉取新镜像并滚动重启 → 失败秒回滚**（镜像 tag 以版本号/commit 为准）。

### 最小可落地流程（4 步）

1) **构建镜像（CI 或本地）**

```bash
docker build -t registry.example.com/bytedance-ai-agent/app:${GIT_SHA} .
```

2) **推送到镜像仓库（Registry）**

```bash
docker push registry.example.com/bytedance-ai-agent/app:${GIT_SHA}
```

3) **服务器拉取并发布（推荐用 compose）**

```bash
# 服务器上
docker pull registry.example.com/bytedance-ai-agent/app:${GIT_SHA}
docker compose up -d --no-deps --pull=never app
```

4) **验证 + 回滚**

- **验证**：健康检查接口（例如 `/healthz`）+ 核心链路冒烟（登录 / chat）
- **回滚**：把镜像 tag 切回上一个版本，再 `docker compose up -d`

### 面试加分点（治理）

- **配置与密钥**：用环境变量/密钥管理（不要打进镜像），区分 dev/staging/prod
- **可观测**：日志/指标/告警（发布后观察 5–10 分钟关键指标）
- **灰度/滚动**：多副本时滚动更新；必要时按用户/流量灰度
- **安全**：最小权限镜像、非 root、定期扫漏洞（Trivy 等）

---

## 1) 什么是“微模块”？

**微模块 = 可独立发布 + 运行时加载的远程模块**（类似 Module Federation/插件化）。  
它解决的是“**一个应用内**的独立发布/插件化/灰度回滚”，运行时复杂度相对可控。

---

## 2) 怎么拆（建议粒度）

### 拆分策略（推荐）

- **按页面/业务域拆**（最稳）：依赖边界清晰，路由天然是加载边界，回滚简单
- 示例：
  - `chat-shell`（主壳）
  - `chat-core`（聊天主页面/路由）
  - `auth-ui`（登录/账号中心）
  - `admin`（运营/后台）
  - `upload-ui`（上传管理页）

### 明确不要做的事（面试官很爱听“边界”）

- 不要一上来就把 `utils/组件库` 全拆成远程模块  
  共享依赖（React、UI 库、markdown 渲染、加密工具）一旦跨远程模块分散，最容易出现：
  - 重复打包/重复加载
  - 版本不一致导致 context 断裂（React hooks、i18n、router）
  - 线上灰度时的兼容地狱

这类更适合做“共享包（shared packages）”，通过 workspace/monorepo 管控版本，而不是运行时远程加载。

---

## 3) 运行时怎么加载（典型模式）

- **Shell（主应用）**
  - 负责：路由、导航、用户会话（你们是 BFF cookie）、错误兜底、远程模块加载器、公共依赖单例（React、router、i18n）
- **Remote（微模块）**
  - 负责：一个业务域的页面/功能，暴露固定入口（例如 `mount()` 或 `routes`），由 shell 注册

> 对比：**微前端**解决的是“多个应用的独立开发部署与聚合”，代价是更重的运行时集成与治理成本。

---

## 4) 实现重点（治理要点）

- **共享依赖必须单例化（最重要）**
  - `react / react-dom / react-router / i18n / zustand` 必须走 shared singleton，否则：hooks 报错、路由上下文丢失、国际化实例不一致
- **版本策略**
  - 最好由 shell “钉死”版本，remote 只声明兼容范围
- **契约与版本化**
  - remote 暴露接口要版本化：例如 `remoteName@1`、`mount({ api, auth, router, container })`
  - 灰度发布要能做到：shell 新、remote 旧（或反过来）还能跑
- **安全（供应链风险）**
  - 远程模块 JS 本质是“线上可变代码”，建议具备：白名单域名、HTTPS、完整性校验（SRI/签名校验思路）、加载失败熔断/回滚（降级到本地旧版本/占位页）
  - 你们有登录与风控：务必确保 remote 不绕过权限校验（关键校验仍在 BFF）
- **性能**
  - 避免把首屏关键路径拆出去导致瀑布加载
  - remote 资源可缓存（contenthash）、支持预加载（prefetch/preload）、按路由懒加载
- **跨模块通信要收敛**
  - 不要互相 import 对方内部文件
  - 通过 shell 的事件总线（你们类似 eventManager）或统一 `shared/contracts`（类型 + 事件定义）
- **BFF/接口层保持稳定**
  - 重点是 API contract 稳定、错误码一致、CSRF 逻辑一致

---

## 5) 什么时候适合考虑“微前端（多个子应用）”？

当核心诉求是“多个前端应用需要独立运行/独立部署/甚至不同技术栈”，且业务边界天然就是“多个应用”时，微前端更匹配：

- 强组织边界：不同业务线/BU 的站点本来就是不同应用，只是希望在同一入口聚合
- 技术栈不统一：React/Vue/Angular 混用，难以统一改造
- 独立域名/独立发布链路：每个子应用各自 CI/CD、监控、发布窗口
- 天然多入口：主站 + 管理后台 + 数据看板 + 客服系统等

不适合的信号：

- 只是想“代码拆得更干净”或“模块独立发布一点点” → 微模块通常就够了

---

## 6) 多 Agent 做成付费功能：用户付费后怎么“及时生效”？

### 一句话答案

把“是否高级用户/是否解锁多 Agent”当成一条**权限/订阅态（entitlement）**来设计：付费完成后由服务端推送变更，前端收到后立刻更新 UI 与能力开关，不依赖用户刷新。

### 3 种方案（可叠加）

- **服务端推送（推荐）**：前端保持长连接（SSE/WebSocket），付费成功后推送 `entitlement_updated`，前端立刻切换能力
- **短周期静默轮询（兜底）**：每隔 10–30 秒请求一次 `/me` 或 `/entitlements`，发现升级就更新
- **Token 自刷新 + 版本号（配合权限校验）**：把“订阅版本号/权限版本号”放在 JWT 或服务端 session；付费后提升版本号，前端下次请求发现不一致就静默换 token/重拉信息

### 推荐落地组合（面试好讲）

**SSE 推送 + 轮询兜底 + 服务端强校验**

- 付费完成（支付回调/webhook）：服务端标记高级（DB/Redis），并发布“用户权限更新事件”
- 在线用户立即生效：找到该用户的 SSE 连接推送 `entitlement_updated`；前端收到后：
  - 立刻更新 `user.isPremium / features.multiAgentEnabled`
  - 再拉一次 `/me`（避免只信事件内容）
  - 解锁多 Agent 按钮与路由/入口
- 离线用户稍后生效：下次打开页面首个 `/me` 就拿到最新权限
- 永远不信前端：后端在多 Agent 相关接口处强校验权限（非高级直接 403/402）

### 关键实现细节（避免“升级了但界面没变”）

- 前端不要只在启动时读一次用户信息：放全局 store，支持被事件/轮询更新
- 缓存要可失效：若后端缓存用户信息（LRU/Redis），付费成功时要主动清/更缓存
- 多端一致：同账号多浏览器/设备，推送 + 轮询能分别尽快同步
  