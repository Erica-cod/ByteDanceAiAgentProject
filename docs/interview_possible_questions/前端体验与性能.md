# 前端侧：面试追问与标准回答（贴合本项目）

## 1) 打字机效果怎么实现的？用 `useRef` 吗？

- **一句话回答**：打字机效果本质是“流式增量更新 UI”，我用 `fetch + ReadableStream` 读 SSE 数据后，持续更新 store 里的最后一条 assistant 消息；为避免卡顿，列表侧做了虚拟化 + 高度重算节流。
- **项目证据**
  - `src/hooks/data/useSSEStream.ts`：解析 `data:` 行，把 `content/thinking` 更新到消息
  - `src/components/old-structure/MessageList.tsx`：流式时对高度重算做阈值（>1000字符变化才触发）+ 800ms 防抖
- **可追问点怎么答**
  - **为什么不逐字 setState**：逐字会导致 re-render 过于频繁；我让服务端按 chunk 推，前端用阈值/防抖控制重排，体感仍然“像逐字”，但性能更稳。

## 2) 流式输出时，换行了滚动条怎么“自动跟随到底部”，并且高度会自动更新？

- **一句话回答**：关键是“只在用户接近底部时跟随”，并且在内容增长到一定幅度后才触发最后一行的重新测量与滚动校准。
- **项目证据**
  - `src/components/old-structure/MessageList.tsx`
    - `isUserNearBottomRef`：跟踪用户是否在底部附近（距离底部 < 100px）
    - 流式变化时：只清最后一行缓存、只重算最后一行高度、再 `scrollToRow(lastIndex)` 校准

## 3) 为什么要做“虚拟列表二次封装”？封装了什么？

- **一句话回答**：聊天列表不是普通列表，它需要处理**动态高度、流式增长、加载历史、队列状态、失败重试、富文本渲染**，所以我把这些“聊天领域能力”封装进 MessageList 组件，避免业务到处散。
- **封装点**
  - **动态高度**：`CellMeasurer + CellMeasurerCache`（测量并缓存每条消息高度）
  - **流式友好**：最后一条消息增长时只重算最后一行（避免全列表重排）
  - **加载历史**：滚动到顶部触发 `onLoadOlder`
  - **稳定性**：遮罩/超时保护，避免切换会话时白屏或抖动
- **项目证据**
  - `src/components/old-structure/MessageList.tsx`
  - `src/components/business/Message/MessageListRefactored.tsx`（重构版：渲染职责进一步拆分到 `MessageItemRenderer`）

## 4) 你文档里提到过 react-virtuoso，为什么现在又不用了？

- **一句话回答**：我早期用过 react-virtuoso，并把滚动坑和修复方案完整记录下来；后续为了更可控的动态高度测量/滚动校准与流式场景稳定性，逐步迁移到 `react-virtualized`。
- **项目证据**
  - `docs/06-Performance-Optimization/VIRTUOSO_SCROLL_FIXES.md`：virtuoso 的典型滚动坑与修复思路（`key` 强制重挂载、绝对索引、followOutput 判断）
  - `package.json`：目前依赖为 `react-virtualized`

## 5) 用户网络不好，消息断了怎么办？

- **一句话回答**：分两层：客户端做短重试（指数退避+抖动），服务端做心跳避免空闲断链；如果资源繁忙则走 429 队列，按 `Retry-After` 重试并保持队列位置。
- **项目证据**
  - `src/hooks/data/useSSEStream.ts`：`MAX_RECONNECT_ATTEMPTS=3`、指数退避、429 队列处理
  - `api/handlers/sseHandler.ts`：`: keep-alive` 心跳（默认 15s）
  - `api/_clean/infrastructure/streaming/sse-limiter.ts` + `api/_clean/infrastructure/queue/queue-manager.ts`：队列 token 与防刷

## 6) 用户一次复制粘贴很大内容到输入框，怎么让滚动不卡、怎么发送到后端？直接发吗？

- **一句话回答**：不直接硬塞一个超大 JSON；我做了“上传策略选择”：小文本直接发，中等文本压缩上传，超大文本压缩后分片上传，上传完成只传 `uploadSessionId` 给 `/api/chat`。
- **项目证据**
  - `src/hooks/data/useSSEStream.ts`：`selectUploadStrategy` → `compressText` → `ChunkUploader.uploadLargeBlob` → `/api/upload/*` → `/api/chat` 只带 `uploadSessionId`
  - `docs/05-Large-Text-Handling/COMPLETE_LARGE_TEXT_SOLUTION.md`：端到端的大文本处理方案（上传/存储/显示）

## 7) Markdown 流式渲染：模型返回 Markdown 不完整/有错误，怎么处理？

- **一句话回答**：流式阶段 Markdown 可能出现半截语法（比如 `**` 未闭合、代码块未闭合、表格行截断、严重格式错误），我实现了**四层容错机制**：⓪ 严重错误检测（降级为纯文本）① Markdown 自动修复器（检测并补全不完整标记）② react-markdown 自带的容错 ③ 备用渲染器（当 react-markdown 失败时降级）。同时隐藏工具/JSON 元数据避免用户看到乱码。
- **项目证据**
  - `src/components/business/Message/StreamingMarkdown.tsx`（增强版组件）
    - `removeJSONFromContent()`：流式阶段如果以 `{` 开头直接隐藏 JSON（避免 `{ "position": ...` 闪现）
    - 整合了四层容错处理和备用渲染器
  
  - `src/utils/markdownFixer.ts`（容错修复工具）
    - **第0层：严重错误检测**
      - `hasSevereFormatError()`：检测严重格式错误，如 `<div class="test"` (标签未闭合 `>`)、`<<<<<<` (大量特殊字符)、`[[[[[[` (严重不平衡括号)
      - 如果检测到严重错误 → 直接降级为纯文本输出（`<pre>` 标签），不尝试渲染
    - **第1层：自动修复器**
      - `fixIncompleteCodeBlocks()`：检测未闭合的代码块（奇数个 \`\`\`），自动添加闭合标记
      - `fixIncompleteHtmlTags()`：用栈算法检测未闭合的 HTML 标签，自动补全
      - `fixIncompleteLinks()`：修复不完整的链接和图片标记（缺少闭合括号）
      - `fixIncompleteTables()`：检测表格行列数不匹配，自动补全缺失列
      - `safeFixMarkdown()`：只在检测到流式传输特征时应用修复（避免误伤）
  
  - `src/utils/fallbackMarkdownRenderer.tsx`（备用渲染器 - 第3层）
    - 手工实现的 Markdown 解析器，支持标题、粗体、斜体、代码块、链接、表格、列表等
    - 当 react-markdown 加载失败或抛出异常时自动降级，确保内容始终可读
    - 支持 GFM 扩展（表格、删除线）
- **四层容错架构**
  ```
  严重错误检测 → 纯文本输出（<div class="test"）
         ↓ (无严重错误)
  自动修复器 → 补全不完整标记（```python）
         ↓
  react-markdown → 利用其容错能力
         ↓ (失败时)
  备用渲染器 → 手工解析 Markdown
  ```

- **可追问点怎么答**
  - **为什么不直接等完整再渲染**：会损失流式体验，用户感知等待时间变长；我选择"尽力修复+优雅降级"，既保证流畅又防止白屏
  
  - **容错修复会不会误伤正常内容**：不会，`safeFixMarkdown()` 只在检测到流式传输特征时才应用（如末尾是 \`\`\`、未闭合的标签等），完整内容不会被修改
  
  - **什么情况下会降级为纯文本**：当检测到严重格式错误时（如 HTML 标签语法错误 `<div class="test"`、大量连续特殊字符 `<<<<<<`），因为这些错误无法通过简单修复恢复，强行渲染可能导致更严重的问题
  
  - **react-markdown 的容错机制是什么**：
    - **核心原理**：react-markdown 基于 `unified` 生态（`remark` + `rehype`），使用 **AST（抽象语法树）** 解析 Markdown
    - **容错策略**：
      1. **宽松解析**：遇到不完整标记时不会报错，而是将其视为普通文本
      2. **增量解析**：每次内容更新都重新解析整个字符串，所以当 `**文本` 变成 `**文本**` 时，会自动识别为粗体
      3. **回退机制**：如果某个语法规则不匹配，会尝试其他规则，最终回退到纯文本
    - **工作流程**：
      ```
      Markdown文本 → remark解析成AST → 插件转换AST → rehype转为HTML AST → React组件渲染
      ```
    - **为什么还需要手动修复**：react-markdown 对于"完全缺失闭合标记"的情况（如只有开始的 \`\`\`），会将后续所有内容都视为代码块，导致渲染错误；我们的修复器在这之前补全标记，避免这种情况
  
  - **备用渲染器性能如何**：手工解析性能足够（单条消息通常不超过几千字），且只在 react-markdown 失败时才启用，正常情况下不影响性能（+10-20ms）

## 8) 识别 token/秒开缓存放 localStorage，怎么防止恶意注入/盗取？为什么不用 cookie？

- **一句话回答**：核心原则是**不在浏览器长期保存“高价值秘密”**；本项目无登录体系更偏“设备隔离 + 本地加密缓存”，如果未来引入真正的鉴权 token，生产建议用 HttpOnly Cookie + CSP 等组合拳。
- **项目证据**
  - `docs/02-Security-System/README.md`：无登录安全系统设计（设备指纹、加密缓存、数据隔离）
- **更稳的补充**
  - XSS 是前端最大风险，所以渲染层默认不执行 raw HTML（见 StreamingMarkdown），并且建议上线时补充 CSP、严格依赖审计、避免 `dangerouslySetInnerHTML`。

## 9) LCP/CLS 等指标你怎么优化的？你还关注哪些指标？

- **一句话回答**：我按 Web Vitals 去拆：LCP 主要靠关键资源加载与渲染路径优化；CLS 主要靠稳定布局和虚拟列表的高度策略；另外关注 FID/INP、内存泄漏、长列表 60fps。
- **项目证据**
  - `docs/06-Performance-Optimization/README.md`：LCP 从 3.5s → 1.2s、CLS 优化、内存泄漏修复、虚拟化策略

## 10) 黑白切换 / 多语言怎么做的？

- **一句话回答**：主题用 CSS 变量/主题样式文件切换；多语言用 i18next 体系，在 UI 层统一走翻译资源。
- **项目证据**
  - `src/i18n/*`、`src/themes/*`、`docs/12-Miscellaneous/I18N_AND_THEME_GUIDE.md`（如果面试官追问可直接指向实现）


