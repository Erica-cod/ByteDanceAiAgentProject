<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SSE æµå¼æ¸²æŸ“æ€§èƒ½æµ‹è¯•</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    .test-box {
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 8px;
    }
    .test-box h3 {
      margin-top: 0;
    }
    .output {
      background: #f5f5f5;
      padding: 10px;
      min-height: 200px;
      border-radius: 4px;
      overflow-y: auto;
      max-height: 300px;
    }
    .stats {
      margin-top: 10px;
      padding: 10px;
      background: #e3f2fd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    button {
      background: #2196F3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #1976D2;
    }
    .warning {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h1>ğŸš€ SSE æµå¼æ¸²æŸ“æ€§èƒ½å¯¹æ¯”æµ‹è¯•</h1>
  
  <div class="warning">
    âš ï¸ è¿™ä¸ªæµ‹è¯•æ¨¡æ‹Ÿäº† 100 ä¸ª SSE chunkï¼Œæ¯ä¸ª chunk é—´éš” 10msï¼Œæ€»å…± 1 ç§’ã€‚<br>
    âš¡ å…³é”®ï¼šRAF æ‰¹å¤„ç†ä¼šå°†åŒä¸€å¸§ï¼ˆ~16msï¼‰å†…çš„å¤šä¸ª chunks åˆå¹¶ä¸º 1 æ¬¡æ¸²æŸ“ï¼<br>
    ğŸ“Š é¢„æœŸç»“æœï¼šæ–¹æ¡ˆ 2 æ¸²æŸ“æ¬¡æ•°çº¦ä¸ºæ–¹æ¡ˆ 1 çš„ 60%ã€‚
  </div>

  <div>
    <button onclick="runAllTests()">ğŸ”¥ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
    <button onclick="clearAll()">ğŸ§¹ æ¸…ç©ºç»“æœ</button>
  </div>

  <div class="container">
    <!-- æ–¹æ¡ˆ 1ï¼šæ¯æ¬¡éƒ½æ›´æ–° -->
    <div class="test-box">
      <h3>âŒ æ–¹æ¡ˆ 1ï¼šæ¯æ¬¡éƒ½æ›´æ–°ï¼ˆæœªä¼˜åŒ–ï¼‰</h3>
      <div id="output1" class="output"></div>
      <div id="stats1" class="stats">ç­‰å¾…æµ‹è¯•...</div>
      <button onclick="testMethod1()">è¿è¡Œæµ‹è¯• 1</button>
    </div>

    <!-- æ–¹æ¡ˆ 2ï¼šRAF æ‰¹å¤„ç† -->
    <div class="test-box">
      <h3>âœ… æ–¹æ¡ˆ 2ï¼šRAF æ‰¹å¤„ç†ï¼ˆæ¨èï¼‰</h3>
      <div id="output2" class="output"></div>
      <div id="stats2" class="stats">ç­‰å¾…æµ‹è¯•...</div>
      <button onclick="testMethod2()">è¿è¡Œæµ‹è¯• 2</button>
    </div>

    <!-- æ–¹æ¡ˆ 3ï¼šuseRef ç›´æ¥æ“ä½œ DOM -->
    <div class="test-box">
      <h3>âš ï¸ æ–¹æ¡ˆ 3ï¼šuseRef + innerHTML</h3>
      <div id="output3" class="output"></div>
      <div id="stats3" class="stats">ç­‰å¾…æµ‹è¯•...</div>
      <button onclick="testMethod3()">è¿è¡Œæµ‹è¯• 3</button>
    </div>

    <!-- æ–¹æ¡ˆ 4ï¼šæ—¶é—´èŠ‚æµï¼ˆ100msï¼‰ -->
    <div class="test-box">
      <h3>ğŸ¯ æ–¹æ¡ˆ 4ï¼šæ—¶é—´èŠ‚æµï¼ˆ100msï¼‰</h3>
      <div id="output4" class="output"></div>
      <div id="stats4" class="stats">ç­‰å¾…æµ‹è¯•...</div>
      <button onclick="testMethod4()">è¿è¡Œæµ‹è¯• 4</button>
    </div>
  </div>

  <script>
    // æ¨¡æ‹Ÿ SSE æ•°æ®æµ
    const CHUNKS = Array.from({ length: 100 }, (_, i) => `Chunk ${i + 1} `);
    const CHUNK_INTERVAL = 10; // 10ms

    // ========== æ–¹æ¡ˆ 1ï¼šæ¯æ¬¡éƒ½æ›´æ–°ï¼ˆæœªä¼˜åŒ–ï¼‰==========
    function testMethod1() {
      return new Promise(resolve => {
        const output = document.getElementById('output1');
        const stats = document.getElementById('stats1');
        output.innerHTML = '';
        
        let content = '';
        let renderCount = 0;
        let chunkIndex = 0;
        const startTime = performance.now();

        // âœ… ä½¿ç”¨ setTimeout æ¨¡æ‹ŸçœŸå®çš„ SSE æµï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰
        function processNextChunk() {
          if (chunkIndex >= CHUNKS.length) {
            const duration = performance.now() - startTime;
            stats.innerHTML = `
              æ¸²æŸ“æ¬¡æ•°: ${renderCount} æ¬¡<br>
              æ€»è€—æ—¶: ${duration.toFixed(2)}ms<br>
              å¹³å‡æ¯æ¬¡: ${(duration / renderCount).toFixed(2)}ms<br>
              <span style="color: red;">âš ï¸ æ¸²æŸ“æ¬¡æ•° = chunk æ•°é‡</span>
            `;
            resolve();
            return;
          }

          content += CHUNKS[chunkIndex];
          
          // æ¯æ¬¡éƒ½ç«‹å³æ¸²æŸ“ï¼ˆåŒæ­¥ï¼‰
          output.textContent = content;
          renderCount++;
          
          chunkIndex++;
          setTimeout(processNextChunk, CHUNK_INTERVAL);
        }

        processNextChunk();
      });
    }

    // ========== æ–¹æ¡ˆ 2ï¼šRAF æ‰¹å¤„ç† ==========
    function testMethod2() {
      return new Promise(resolve => {
        const output = document.getElementById('output2');
        const stats = document.getElementById('stats2');
        output.innerHTML = '';
        
        let content = '';
        let renderCount = 0;
        let rafId = null;
        let pendingContent = null;
        let chunkIndex = 0;
        const startTime = performance.now();

        const scheduleRender = () => {
          pendingContent = content;
          
          if (rafId !== null) return; // âœ… å¦‚æœå·²ç»å®‰æ’äº† RAFï¼Œè·³è¿‡ï¼ˆå…³é”®ï¼ï¼‰

          rafId = requestAnimationFrame(() => {
            output.textContent = pendingContent;
            renderCount++;
            pendingContent = null;
            rafId = null;
          });
        };

        // âœ… ä½¿ç”¨ setTimeout æ¨¡æ‹ŸçœŸå®çš„ SSE æµï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰
        function processNextChunk() {
          if (chunkIndex >= CHUNKS.length) {
            // ç­‰å¾…æœ€åä¸€æ¬¡ RAF å®Œæˆ
            setTimeout(() => {
              const duration = performance.now() - startTime;
              stats.innerHTML = `
                æ¸²æŸ“æ¬¡æ•°: ${renderCount} æ¬¡<br>
                æ€»è€—æ—¶: ${duration.toFixed(2)}ms<br>
                å¹³å‡æ¯æ¬¡: ${(duration / renderCount).toFixed(2)}ms<br>
                <span style="color: green;">âœ… æ¸²æŸ“æ¬¡æ•°å‡å°‘ ${((1 - renderCount / CHUNKS.length) * 100).toFixed(0)}%</span>
              `;
              resolve();
            }, 20);
            return;
          }

          content += CHUNKS[chunkIndex];
          
          // å®‰æ’æ¸²æŸ“ï¼ˆå¯èƒ½è¢«åˆå¹¶ï¼‰
          scheduleRender();
          
          chunkIndex++;
          setTimeout(processNextChunk, CHUNK_INTERVAL);
        }

        processNextChunk();
      });
    }

    // ========== æ–¹æ¡ˆ 3ï¼šuseRef + innerHTML ==========
    function testMethod3() {
      return new Promise(resolve => {
        const output = document.getElementById('output3');
        const stats = document.getElementById('stats3');
        output.innerHTML = '';
        
        let renderCount = 0;
        let chunkIndex = 0;
        const startTime = performance.now();

        function processNextChunk() {
          if (chunkIndex >= CHUNKS.length) {
            const duration = performance.now() - startTime;
            stats.innerHTML = `
              DOM æ“ä½œæ¬¡æ•°: ${renderCount} æ¬¡<br>
              æ€»è€—æ—¶: ${duration.toFixed(2)}ms<br>
              å¹³å‡æ¯æ¬¡: ${(duration / renderCount).toFixed(2)}ms<br>
              <span style="color: orange;">âš ï¸ æ— æ³•ä½¿ç”¨ React ç»„ä»¶å’Œ Markdown</span>
            `;
            resolve();
            return;
          }

          // ç›´æ¥æ“ä½œ DOMï¼Œä¸è§¦å‘ React é‡æ¸²æŸ“
          output.textContent += CHUNKS[chunkIndex];
          renderCount++;
          
          chunkIndex++;
          setTimeout(processNextChunk, CHUNK_INTERVAL);
        }

        processNextChunk();
      });
    }

    // ========== æ–¹æ¡ˆ 4ï¼šæ—¶é—´èŠ‚æµ ==========
    function testMethod4() {
      return new Promise(resolve => {
        const output = document.getElementById('output4');
        const stats = document.getElementById('stats4');
        output.innerHTML = '';
        
        let content = '';
        let renderCount = 0;
        let lastRenderTime = 0;
        let chunkIndex = 0;
        const THROTTLE_MS = 100;
        const startTime = performance.now();

        function processNextChunk() {
          if (chunkIndex >= CHUNKS.length) {
            // æœ€åä¸€æ¬¡æ›´æ–°
            output.textContent = content;
            renderCount++;

            const duration = performance.now() - startTime;
            stats.innerHTML = `
              æ¸²æŸ“æ¬¡æ•°: ${renderCount} æ¬¡<br>
              æ€»è€—æ—¶: ${duration.toFixed(2)}ms<br>
              å¹³å‡æ¯æ¬¡: ${(duration / renderCount).toFixed(2)}ms<br>
              <span style="color: blue;">ğŸ¯ å›ºå®šæ›´æ–°é¢‘ç‡ï¼ˆ100msï¼‰</span>
            `;
            resolve();
            return;
          }

          content += CHUNKS[chunkIndex];
          
          const now = Date.now();
          if (now - lastRenderTime >= THROTTLE_MS) {
            output.textContent = content;
            renderCount++;
            lastRenderTime = now;
          }
          
          chunkIndex++;
          setTimeout(processNextChunk, CHUNK_INTERVAL);
        }

        processNextChunk();
      });
    }

    // å·¥å…·å‡½æ•°
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runAllTests() {
      console.log('ğŸš€ å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...');
      await testMethod1();
      await sleep(200);
      await testMethod2();
      await sleep(200);
      await testMethod3();
      await sleep(200);
      await testMethod4();
      console.log('âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆï¼');
    }

    function clearAll() {
      for (let i = 1; i <= 4; i++) {
        document.getElementById(`output${i}`).innerHTML = '';
        document.getElementById(`stats${i}`).innerHTML = 'ç­‰å¾…æµ‹è¯•...';
      }
    }
  </script>
</body>
</html>

